# SQL, Skriptejä ja Weppiä



## x)

## y)

## a) SQLZoo -tehtäviä

Tehtävänantona käydä läpi tehtävät SQLZoo:n sivuston osista **0 - SELECT basics** ja **2 SELECT from World**. Sivusto on tehty apuvalineeksi SQL -kielen opiskelussa.

Osassa SELECT Basics annettiin taulukko maailman maista, ja niiden erinäisistä statseista (Koko, väkiluku, jne), johon sivun tehtävät perustuivat. Tehtävissä annettiin valmis SQL -koodipätkä, joka hakee sen määrittelemänä tietoa taulukosta, ja tätä koodia piti muokata tehtävänannon mukaisesti. Alla kuvakaappaukset tehtävistä ratkaisun jälkeen, ja pieni selostus SQL:stä.

![image](https://user-images.githubusercontent.com/94109769/200350282-6136010a-6c71-4442-96ee-17bd2a405566.png)

Tämä on SQL:n peruskauraa. SELECT komennolla haetaan tieto taulukosta (tässä tapauksessa "population"), ja samalla rivillä tämän jälkeen FROM määrittelee mistä taulukosta ("world"). WHERE määritelmä tämän järkeen kertoo miten haettua tietoa filtteroidaan. Tässä tapauksessa ``WHERE name = 'x'`` kertoo koodille, että haluamme väkiluvutiedon riviltä, jolla 'name' kentässä on jokin tietty arvo. Alkuperäisessä koodissa tämä tieto oli 'France', mutta muutin siihen 'Germany', jotta saatiin Saksan väliluku.

![image](https://user-images.githubusercontent.com/94109769/200351116-9bae98e4-5d7d-4a5e-b4b5-5f2a89ec76e6.png)

Tällä koodilla poimittiinkin useampi kenttä taulukosta. SELECT lausekkeella voi siis pilkun kanssa lisätä useita haettavia asioita hakuun. Samalla lailla WHERE määritelmän jälkeen ``name IN`` ja sulkujen sisään lisätyt, pilkulla erotetut termit saavat hakemaan useammalla eri hakutermillä. Kaiken tämän tuloksena siis listataan taulukkoon Ruotsin, Norjan ja Tanskan väkiluvut maiden nimien kanssa.

![image](https://user-images.githubusercontent.com/94109769/200361987-fce15521-481c-4d00-a6e2-db5989ec33e3.png)

Tässä tapauksessa WHERE sanan jälkeen käytettiinkin hakutermia, ja sen jälkeen BETWEEN määritelmää, jolla määritellä kaksi eri numeroa joiden väliltä halutusta kentästä haetaan tietoa. Tällä lauseella haettiin siis maat, joiden väkiluku on suurempi kuin 200000, mutta pienempi kuin 250000

Tämän jälkeen siirryin osaan **2 SELECT from World**, jossa vastauksia pitikin jo hakea itsekkin.

![image](https://user-images.githubusercontent.com/94109769/200363080-eafe4ba6-fadf-4bf1-a443-6d44382a6633.png)

Tehtävä 1:ssä tässä osiossa haluttiin siis vaan näyttää, miten tuo koodi ylipäätänsä toimii. Painamalla vaan ajo-nappia päästiin näkemään listaus.

![image](https://user-images.githubusercontent.com/94109769/200363258-6abc7b56-286c-477f-8b6f-b735eff23c01.png)

Tässä tehtävässä esimerkkikoodissa WHERE filtteri olikin kirjoitettu alunperin ``WHERE population = #####``, jolla haettiin maata jonka väkiluku täsmäsi tarkalleen annettua numeroa. Tehtävässä haluttiin tosin listattavan kaikki maat, joissa oli vähintään kaksi miljoonaa asukasta. Tämä toimi muuttamalla yhtäsuuruus merkin toiseksi matemaattiseksi merkiksi >=, joka tarkoittaa siis että tulos on suurempi TAI yhtä suuri kuin annettu määritelmä.

![image](https://user-images.githubusercontent.com/94109769/200364260-0b5c0b4c-d993-4ad1-b2ec-ef70570c4115.png)

Tässä tehtävässä ei ollutkaan valmiiksi yhtään koodia, joten kaikki SQL piti kirjoittaa itse. Hankalammaksi tästä teki myös sen, että tehtävä vaati GDP Per Capita lukua. Onneksi tehtävästä löytyi myös vihje joka kertoi miten se lasketaan. Laskutoimituksen selvityksen jälkeen se piti vain syöttää SELECT lausekkeeseen haettavien kenttien joukkoon; nämäkin siis ottavat vastaan laskutoimituksia, ja koska molemmissa 'population' ja 'gdp' kentissä oli numeroita eikö tekstiä, hakusana ``gdp/population`` kelpasi, ja SQL-koodi automaattisesti käytti kahta termiä muuttujina, jotka korvattiin haettujen numeroidne jakotoimituksen tuloksena.

![image](https://user-images.githubusercontent.com/94109769/200365070-c80d467d-e434-4c6a-8415-32723642f47d.png)

Tässäkään tehtävässä ei ollut yhtään valmiiksi-kirjoitettua koodia, mutta sen vastaus seurasi samoja tekniikoita kuin pari aikaisempaakin.

![image](https://user-images.githubusercontent.com/94109769/200365559-bdd1d623-9f83-4d1e-a9d5-6ec7b98188c5.png)

Tässäkään tehtävässä ei valmista koodia. Tässä vaiheessa tämän koodin kirjoittaminen tosin tuli jo oikeastaan automaattisesti.

Tästä osiosta pyydettiin tekemään vain tehtävät 1-5, joten jätin SQLZoo:ssa seikkailun tähän.

## b) DVWA: Paikallinen tunnus

## c) DVWA: Command Execution

DVWA:n sisällä oli Command Execution osio, jota olisi tarkoitus mennä kokeilemaan sen jälkeen, kun Security Level oli asennettu low:ksi.

![image](https://user-images.githubusercontent.com/94109769/200434276-58bb0493-5639-4277-a5d9-054c4b79aa31.png)

Syöttämällä ihan puhtaasti localhost-osoitteen kenttään, sain seuraavan tuloksen:

![image](https://user-images.githubusercontent.com/94109769/200434354-84c288b4-d9fc-4ba6-8c00-44586524a3b5.png)

Tunnistin tulosteen saman tien. Ohjelma ilmeisesti ajoi PING komennon annetulle osoitteella Metasploitable-koneella, ja lähetti takaisen siitä tulleen tulosteen. Eli toisin sanoen, tällä ohjelmalla pääsen teoriassa ajamaan suoraan komentoja kohdekoneen komentorivillä. View Help napista sain myös nopeasti muistutettua itseäni, että komentoja voi linuxilla ajaa peräkkäin yhdellä syötöllä jakamalla niitä ; -merkillä. Kokeilin uteliaisuudesta siis lisätä syötteeseen whoami komennon (``127.0.0.1;whoami``):

![image](https://user-images.githubusercontent.com/94109769/200434855-21c56e3b-2944-4527-a313-f52176a22246.png)

Tästä selvisi että ohjelma ajaa komentoja www-data -käyttäjän alla. Harmi sinänsä, koska tällä todennäköisesti on aika rajatut oikeudet. Tällä tavalla kuitenkin saa jo hyvin tietoja kerättyä, esimerkiksi tarkistaa passwd -tiedoston sisällön palvelimella olevien käyttäjien listaamiseksi. Metasploitin kaltaisella koneella saisi varmasti privilige escalationiakin tehtyä tämän ja netcat yhteyden kautta, mutta en nyt paneutunut siihen.


## d) Vuohen Injektioita

Tehtäväksi annettiin ratkoa muutama tehtävä WebGoatista.

### A1 Injection (Intro)

Tehtäväosio alkoi SQL:n perusteella toisella sivulla, jossa myös kehotettiin kokeilemaan hakemaan annetusta tietokanta -pöydästä tietyn työntekijän osasto. Tämä onnistui lausekkeella ``SELECT department FROM employees WHERE first_name = 'Bob' AND last_name = 'Franco'``.

Seuraavalla sivulla käsitettiinkin DML -komentoja. Tämä oli minulle tuntemattomampi, mutta nopeasti pääsin ymmärrykseen, että sitäkin käytettiin tietokantojen käsittelyyn, ja piti sisällään monia samoja komentoja kuin myös SQL. Sivulla oli myös kehotus kokeilla muuttamaan edellisen sivun taulusta työntekijän Tobi Barnett osasto 'Sales':ksi. Tämä onnistui lausekkeella ``UPDATE employees SET department = 'Sales' WHERE first_name = 'Tobi* AND last_name = 'Barnett';``.

Sivu 4 käsitteli DDL-komentoja. Nämäkin olivat minulle tuntemattomampia, mutta sivu selitti, että niitä käytetään tietokanta-pöydän rakenteen muuttamiseen tai luomiseen. Tässä tapauksessa haluttiin luovan lauseke, jolla 'employees' tauluun lisättäisiin kenttä '"phone" (varchar(20))'. Tähän minun piti tarkistaa netistä nopeasti [ohjeita lausekkeen tekemiseen (link)](http://www1.udel.edu/evelyn/SQL-Class1/SQLAlter.html), mutta tämän jälkeen sain luotua lauseen ``ALTER TABLE employees ADD COLUMN phone Varchar(20);``.

Sivu 5 käsitteli DCL -komentoja, joilla luodaan oikeuksia käyttäjille tietokannan käyttöön ja muokkaamiseen. Tällä sivulla kokeilutehtävänä oli luoda lauseke, jolla annetaan käyttäjäryhmälle "UnauthorizedUser" oikeus muokata tietokantapöytiä. Sivulla annetun esimerkin perusteella yritin kokeilumielessä lauseketta ``GRANT ALTER TABLE TO UnauthorizedUser;``, ja se yllättäen jopa toimi.

Seuraavat kolme sivua olivat puhtaasti teoriaa, joka käsittelivät SQL-injektioita. SQL injektio on siis tekniikka, jossa syötetään SQL-koodia webbiohjelmaan, joka normaalisti syöttää vain käyttäjän inputin backendissä tehtyyn SQL-lausekkeeseen ilman mitään sanitaatiota. Tällä tavalla ilkeämielinen taho voisi syöttää webbiselaimensa kautta SQL-koodia palvelimelle, jota ei ollut tarkoitus ajaakkaan, ja täten joko hakea tietoa jota ei normaalisti pitäisi olla saatavilla, tai tehdä luvattomia muutoksia tietokannalle, tai pahimmillaan jopa lähettää komentoja käyttöjärjestelmälle.

Sivulla 9 piti lausekkeelle ``SELECT * FROM user_data WHERE first_name = 'John' AND last_name= '" + lastName + "'";`` kohdan last_name= jälkeen lisätä oikea yhdistelmä sanoja koodiin, jotta saattiin haettua lista kaikista tietokannan käyttäjistä. Tämä onnistui valinnoilla ', OR ja '1' = '1, sillä tämän avulla koodiin syötettiin käytännössä hakufiltteri  "or TRUE", ja kun ohjelma hakee tuloksia tätä vastaan, jokainen tulos luetaan haetuksi riviksi.

Sivulla 10 kokeiltiin numeerista injektiota. Lausekkeeseen ``SELECT * FROM user_data WHERE login_count = " + Login_count + " AND userid = " + User_ID;`` piti lisätä syötteet Login_count ja user_id kentille, jotta saadaan haettua tietoa kaikista kannassa olevista käyttäjistä. En ihan ymmärtänyt kunnolla, mitä virkaa Login_count kenttä tässä koodissa ajaa, mutta edellisen esimerkkiä noidattaen, ja huomioiden sivun huomautuksen että vain yksi kentistä on altis injektiolle, kokeilin ensin syöttää Login_count:ksi 0:n, ja User_Id kenttään "0 OR 1=1". Tämä sattuikin jo heti toimimaan, ja sain kaikki käyttäjiätiedot itselleni tutkittavaksi.

Sivulla 11 oli tehtävä, joka hyödynsi kahden aikaisemman käyttämiä asioita. Kuvitteellisena skenaariona oli halukkuus hakea tietoja kaikista työntekijöistä firmasta systeemin kautta, joka antaisi näyttää omat tiedot nimen ja yksilöidyn tunnistekoodin kautta. Tähän ohjelma käyttää lauseketta ``SELECT * FROM employees WHERE last_name = '" + name + "' AND auth_tan = '" + auth_tan + "';``. Kentät, joihin nyt voi syöttää dataa, olivat "Employee Name" ja "Authentication Tan". Muistellen kahden ensimmäisen tehtävän esimerkkejä, syötin Employee Name -kohtaan vain 0:n (tosin tälle kentälle ei ole niin olennaista, mitä sille pistää), ja Authenticat TAN kenttään ``' OR '1'=1``, ja kaikkien muiden työntekijöiden tiedot tulivat esille.

Sivun 12 tehtävässä menikin hieman enemmän aikaa itselläni tajuta, miten tehtävä saatiin ratkottua. Tarkoituksena oli siis SQL -kyselyketjun avulla ajettua kohdekoneen kannalle useampi komentolauseke, kuin mitä olisi tarkoituksenmukaista. Tämä tehtävä käytti edellisen sivun tehtävän samaa skenaariota jatkaen siitä, että nyt haluttiinkin muuttaa oma palkka suurimmaksi. Tämä saatiin loppujen lopuksi tehtyä hyödyntäen ; -merkkiä, jota käytetään erottajana kyselylausekkeilla. Lauseke, jolla skenaarion käyttäjä muutettaisiin korkeimmaksi tässä tapauksessa olisi ``UPDATE employees SET salary=90000 WHERE auth_tan = '3SL99A'``, mutta tähän pitää tietenkin alkuun lisätä merkit ``';``, jotta saadaan injektoitua koodi joka lopettaa alunperin toimivan hakukyseln, ja ajaa lausekkeen joka on kirjoitettu näiden oikealla puolella -- ja poistaa lopusta myös stringin-sulkija ', koska backendin ohjelmisto lisää sen omalla puolellaan automaattisesti. Eli Authentication TAN -kenttään tällä sivulla suoritetaan ratkaisuksi ``'; UPDATE employees SET salary=90000 WHERE auth_tan = '3SL99A``.

Sivulla 13 selvisi, että kannassa on myös access_log pöytä, johon on kirjattu kaikki toiminnot, jota ollaan tietokannalle menty tekemään... mukaanlukien oman palkkalukeman muokkaukset. Hupsista. Tehtävä kehotti poistamaan koko pöydän. Itselläni oli hieman uteliaisuutta nähdäkkin tämä kantapöytä, mutta en keksinyt miten sen olisin saanut tällä sivulla tarjotulla syötekentän avulla sen saamaan näkymiin, joten tyydyin vain kylmästi sen poistoon. DDL komentoja käsittelevällä sivulla mainittin DROP komento, ja tämän perusteella päättelin että lauseke jolla pöydän saa poistettua olisi ``DROP table access_log``, ja tähän taas luonnolisesti alkuun ensin ``';`` jotta tämä saadaan injektoitua ohjelmaan. Ainakin uskoin tämän toimineen näin, mutta komento ei toiminutkaan. Vielä hetken pähkäilyn jälkeen päätin vihdoin käydä kylmästi lunttaamassa, miten tehtävä ratkaistiin. Löydin [sivun jossa tehtävää käsiteltiin](https://docs.cycubix.com/web-application-security-essentials/solutions/a1-injection/sql-injection-intro-13), ja sieltä selvisi että lauseke oli kyllä muuten oikein, mutta sinne oli lisätty ``--`` loppuun, joka kommentoi pois loput rivistä. Kokeilemalla itse lisätä nämä merkit kirjoittamalleni koodilleni, tehtävä meni sen jälkeen lävitse.

### A2 Broken Authentication - Password Reset

Kotitehtävät ohjeistivatkin siirtymään seuraavaksi A2 osioon, ja sen alta Authentication Bypass -osiosta 2FA Password Reset -tehtävä.

### A3 Sensitive Data Exposure

Osiossa käytiin käytännössä lävitse, kuinka tärkeää turvatut yhteydet ja datan salaus on. Harjoituksena kehotettiin tehtävä-osiossa kaappamaan tietoa, joka "Log In" napin painaksullesta simuloi kirjautumisen sivulle toisen käyttäjän toimesta -- ja tämän kirjautumisen tiedot pitäisi kaapata.

Käynnistin Wiresharkin Webgoat -koneellani, ja asetin sen kaappaamaan paketteja Loopback interfacelta -- tässä tapauksessa tämä toimii, koska Webgoat palvelinkin toimii samalla koneella. Kaappauksen aloittamisen jälkeen painoin webgoatin tehtäväsivulla Log In -nappia, ja pysäytin melkein heti tämän jälkeen Wiresharkin kaappaamisen. TÄllä tavallahan sain kaapattua hirveänkin määrän paketteja, joten filtteröin niitä näyttämään ainoastaa http POST paketit (filtterikenttään: http.request.method == "POST". Tämän jälkeen silmääni pisti seuraava rivi pakettien listassa:

![image](https://user-images.githubusercontent.com/94109769/201382011-b8130f5a-6cd2-43e0-87d9-e97ca06ee531.png)

Avasin tämän paketin, ja selasin sitä lävitse.

![image](https://user-images.githubusercontent.com/94109769/201382079-fcdf53fa-8656-4bb3-aba4-d3d318c2ed0d.png)

Ja sieltä löytyi käyttäjänimi ja salasana selkotekstinä. PAketti kulki salaamattoman HTTP-liikenteen kautta, joten sen saisi samassa verkossa varmasti toiseltakin koneelta kaapattua yhtä helposti.



# Lähteet

[http://www1.udel.edu/evelyn/SQL-Class1/SQLAlter.html](http://www1.udel.edu/evelyn/SQL-Class1/SQLAlter.html)
